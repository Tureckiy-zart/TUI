/**
 * Theme Generator
 *
 * Core logic for generating CSS and TypeScript theme files.
 * Takes input parameters and produces complete, valid theme files
 * compatible with Theme Contract v1.
 *
 * @see docs/theming/THEME_SYSTEM_ARCHITECTURE.md
 * @see docs/theming/THEME_EXTENSION_CONTRACT.md
 */

import { existsSync, mkdirSync, writeFileSync } from "fs";
import { dirname, join } from "path";

import type {
  ColorGenerationConfig,
  GeneratedTheme,
  GenerationResult,
  ThemeGeneratorInput,
  ThemeMode,
  ThemeTokens,
} from "./types";

import { generateThemeTokens, parseHSL } from "./token-mapper";
import { getPaletteNameError } from "./validator";

/**
 * Default output directory for generated themes
 */
const DEFAULT_OUTPUT_DIR = "src/EXTENSIONS/themes";

/**
 * Generate CSS content from theme tokens
 */
export function generateCSS(themeId: string, tokens: ThemeTokens): string {
  const lines: string[] = [];

  lines.push(`/**`);
  lines.push(` * Theme: ${themeId}`);
  lines.push(` * Generated by Theme CLI Generator`);
  lines.push(` * Theme Contract Version: v1`);
  lines.push(` *`);
  lines.push(` * @see docs/theming/THEME_SYSTEM_ARCHITECTURE.md`);
  lines.push(` * @see docs/theming/THEME_EXTENSION_CONTRACT.md`);
  lines.push(` */`);
  lines.push(``);
  lines.push(`:root[data-theme="${themeId}"] {`);

  // Add all tokens
  for (const [name, value] of Object.entries(tokens)) {
    lines.push(`  ${name}: ${value};`);
  }

  lines.push(`}`);
  lines.push(``);

  return lines.join("\n");
}

/**
 * Generate TypeScript content from theme tokens
 */
export function generateTS(
  themeId: string,
  palette: string,
  mode: ThemeMode,
  tokens: ThemeTokens,
): string {
  const lines: string[] = [];

  // Convert theme ID to valid variable name
  const varName = themeId.replace(/-/g, "_").replace(/[^a-zA-Z0-9_]/g, "");

  lines.push(`/**`);
  lines.push(` * Theme: ${themeId}`);
  lines.push(` * Generated by Theme CLI Generator`);
  lines.push(` * Theme Contract Version: v1`);
  lines.push(` *`);
  lines.push(` * @see docs/theming/THEME_SYSTEM_ARCHITECTURE.md`);
  lines.push(` * @see docs/theming/THEME_EXTENSION_CONTRACT.md`);
  lines.push(` */`);
  lines.push(``);
  lines.push(`import type { ThemeTokens } from "./types";`);
  lines.push(``);
  lines.push(`export const ${varName}_theme = {`);
  lines.push(`  id: "${themeId}",`);
  lines.push(`  palette: "${palette}",`);
  lines.push(`  mode: "${mode}",`);
  lines.push(`  tokens: {`);

  // Add all tokens
  for (const [name, value] of Object.entries(tokens)) {
    lines.push(`    "${name}": "${value}",`);
  }

  lines.push(`  } as ThemeTokens,`);
  lines.push(`} as const;`);
  lines.push(``);
  lines.push(`export default ${varName}_theme;`);
  lines.push(``);

  return lines.join("\n");
}

/**
 * Generate a single theme for a specific mode
 */
export function generateTheme(input: ThemeGeneratorInput, mode: ThemeMode): GeneratedTheme {
  const { paletteName, baseColor, accentColor, contrastLevel, outputFormat, outputDir } = input;

  // Create theme ID
  const themeId = `${paletteName}-${mode}`;

  // Parse input colors
  const baseColorParsed = parseHSL(baseColor);
  const accentColorParsed = accentColor ? parseHSL(accentColor) : undefined;

  // Generate token configuration
  const config: ColorGenerationConfig = {
    baseColor: baseColorParsed,
    accentColor: accentColorParsed,
    mode,
    contrastLevel: contrastLevel || "AA",
  };

  // Generate tokens
  const tokens = generateThemeTokens(config);

  // Determine file extension and content
  const format = outputFormat || "css";
  const extension = format === "ts" ? "ts" : "css";

  // Generate output content
  let content: string;
  if (format === "ts") {
    content = generateTS(themeId, paletteName, mode, tokens);
  } else {
    content = generateCSS(themeId, tokens);
  }

  // Determine output path
  const dir = outputDir || DEFAULT_OUTPUT_DIR;
  const fileName = `theme.${themeId}.${extension}`;
  const filePath = join(dir, fileName);

  return {
    themeId,
    palette: paletteName,
    mode,
    tokens,
    css: format === "css" ? content : undefined,
    ts: format === "ts" ? content : undefined,
    filePath,
  };
}

/**
 * Write generated theme to file
 */
export function writeThemeFile(theme: GeneratedTheme): void {
  const content = theme.css || theme.ts;
  if (!content) {
    throw new Error(`No content to write for theme: ${theme.themeId}`);
  }

  // Ensure directory exists
  const dir = dirname(theme.filePath);
  if (!existsSync(dir)) {
    mkdirSync(dir, { recursive: true });
  }

  // Write file
  writeFileSync(theme.filePath, content, "utf-8");
}

/**
 * Write multiple generated themes to files
 * Should be called ONLY after validation passes
 */
export function writeThemeFiles(themes: GeneratedTheme[]): void {
  for (const theme of themes) {
    writeThemeFile(theme);
  }
}

/**
 * Main generator function - generates all themes from input
 */
export function generate(input: ThemeGeneratorInput): GenerationResult {
  try {
    // Validate palette name format (Theme Contract v1 compliance)
    const paletteError = getPaletteNameError(input.paletteName);
    if (paletteError) {
      return {
        success: false,
        themes: [],
        error: paletteError,
      };
    }

    if (!input.baseColor) {
      return {
        success: false,
        themes: [],
        error: "Base color is required",
      };
    }

    if (!input.modes || input.modes.length === 0) {
      return {
        success: false,
        themes: [],
        error: "At least one mode (light or dark) is required",
      };
    }

    // Validate modes
    for (const mode of input.modes) {
      if (mode !== "light" && mode !== "dark") {
        return {
          success: false,
          themes: [],
          error: `Invalid mode: "${mode}". Must be "light" or "dark"`,
        };
      }
    }

    // Validate base color format
    try {
      parseHSL(input.baseColor);
    } catch (e) {
      return {
        success: false,
        themes: [],
        error: `Invalid base color format: ${(e as Error).message}`,
      };
    }

    // Validate accent color format if provided
    if (input.accentColor) {
      try {
        parseHSL(input.accentColor);
      } catch (e) {
        return {
          success: false,
          themes: [],
          error: `Invalid accent color format: ${(e as Error).message}`,
        };
      }
    }

    // Generate themes for each mode (in-memory only - no file writing)
    // Files are written by CLI AFTER validation passes
    const themes: GeneratedTheme[] = [];

    for (const mode of input.modes) {
      const theme = generateTheme(input, mode);
      themes.push(theme);
    }

    return {
      success: true,
      themes,
    };
  } catch (error) {
    return {
      success: false,
      themes: [],
      error: `Generation failed: ${(error as Error).message}`,
    };
  }
}

/**
 * Generate themes without writing to files (for validation/preview)
 */
export function generatePreview(input: ThemeGeneratorInput): GenerationResult {
  try {
    // Validate palette name format (Theme Contract v1 compliance)
    const paletteError = getPaletteNameError(input.paletteName);
    if (paletteError) {
      return {
        success: false,
        themes: [],
        error: paletteError,
      };
    }

    if (!input.baseColor) {
      return {
        success: false,
        themes: [],
        error: "Base color is required",
      };
    }

    if (!input.modes || input.modes.length === 0) {
      return {
        success: false,
        themes: [],
        error: "At least one mode (light or dark) is required",
      };
    }

    // Generate themes for each mode (without writing)
    const themes: GeneratedTheme[] = [];

    for (const mode of input.modes) {
      const theme = generateTheme(input, mode);
      themes.push(theme);
    }

    return {
      success: true,
      themes,
    };
  } catch (error) {
    return {
      success: false,
      themes: [],
      error: `Generation failed: ${(error as Error).message}`,
    };
  }
}
